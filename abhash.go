package abhash

// üî• ABHash —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è:
//   - –ü—Ä–∏–Ω–∏–º–∞–µ—Ç:
//     ‚Äì data: –∏—Å—Ö–æ–¥–Ω—ã–π —Å—Ä–µ–∑ –±–∞–π—Ç ([]byte)
//     ‚Äì sohp: –æ–∂–∏–¥–∞–µ–º—ã–π —Ä–∞–∑–º–µ—Ä —á–∞—Å—Ç–∏ –¥–ª—è —Ö–µ—à–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 2)
//     ‚Äì hpa: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–µ–π —Ö–µ—à–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 2)
//   - –†–∞–∑–±–∏–≤–∞–µ—Ç –≤—Å–µ –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ hpa —á–∞—Å—Ç–µ–π —Ç–∞–∫, —á—Ç–æ –ø–µ—Ä–≤—ã–µ hpa-1 —á–∞—Å—Ç–µ–π –∏–º–µ—é—Ç –¥–ª–∏–Ω—É sohp,
//     –∞ –ø–æ—Å–ª–µ–¥–Ω—è—è —á–∞—Å—Ç—å –ø–æ–ª—É—á–∞–µ—Ç –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –±–∞–π—Ç—ã (–æ–Ω–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ sohp).
//   - –î–ª—è –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è —Ç–æ–∫–µ–Ω —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ sohp —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º XOR‚Äë—Å–≤—ë—Ä—Ç–∫–∏
//     –∏ –ø–æ–±–∏—Ç–æ–≤–æ–≥–æ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑–º–µ–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ç–æ–∫–µ–Ω —Ç–æ–π —á–∞—Å—Ç–∏,
//     –≤ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–æ–∏–∑–æ—à–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è.
func ABHash(data []byte, sohp int, hpa int) []byte {
	// üí° –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –∑–∞–¥–∞–Ω—ã –Ω–µ–≤–µ—Ä–Ω–æ
	if sohp <= 0 {
		sohp = 2
	}
	if hpa <= 0 {
		hpa = 2
	}

	// üìã –†–∞–∑–±–∏–≤–∞–µ–º data –Ω–∞ hpa —á–∞—Å—Ç–µ–π.
	// –ü–µ—Ä–≤—ã–µ hpa-1 —á–∞—Å—Ç–µ–π –∏–º–µ—é—Ç —Ä–æ–≤–Ω–æ sohp –±–∞–π—Ç (–∏–ª–∏ –º–µ–Ω—å—à–µ, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –º–∞–ª–æ, —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –±–∞–π—Ç)
	// –ü–æ—Å–ª–µ–¥–Ω—è—è —á–∞—Å—Ç—å –ø–æ–ª—É—á–∞–µ—Ç –≤—Å–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –¥–∞–Ω–Ω—ã–µ.
	parts := make([][]byte, hpa)
	for i := 0; i < hpa-1; i++ {
		start := i * sohp
		end := start + sohp

		// –ï—Å–ª–∏ –Ω–∞—á–∞–ª–æ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã data, —Ç–æ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –µ–≥–æ –¥–æ –¥–ª–∏–Ω—ã data
		if start > len(data) {
			start = len(data)
		}

		// –ï—Å–ª–∏ –∫–æ–Ω–µ—Ü –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã data, —Ç–æ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –µ–≥–æ –¥–æ –¥–ª–∏–Ω—ã data
		if end > len(data) { // –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –º–µ–Ω—å—à–µ, —á–µ–º —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è –æ—á–µ—Ä–µ–¥–Ω–æ–π —á–∞—Å—Ç–∏
			end = len(data)
		}
		parts[i] = data[start:end]
	}
	// –ü–æ—Å–ª–µ–¥–Ω—è—è —á–∞—Å—Ç—å –ø–æ–ª—É—á–∞–µ—Ç –≤—Å—ë –æ—Å—Ç–∞–≤—à–µ–µ—Å—è
	if (hpa-1)*sohp < len(data) {
		parts[hpa-1] = data[(hpa-1)*sohp:]
	} else {
		// –î–æ–±–∞–≤–ª—è–µ–º –ø–∞–¥–¥–∏–Ω–≥ –∫ –ø–æ—Å–ª–µ–¥–Ω–µ–π —á–∞—Å—Ç–∏, –µ—Å–ª–∏ –æ–Ω–∞ –º–µ–Ω—å—à–µ sohp –±–∞–π—Ç
		paddingSize := sohp - len(parts[hpa-1])
		padding := make([]byte, paddingSize)
		parts[hpa-1] = append(parts[hpa-1], padding...)
	}

	// ü§ó –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω—ã –¥–ª—è –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏
	tokens := make([][]byte, hpa)
	for i, part := range parts {
		tokens[i] = generateToken(part, sohp)
	}

	// üîÑ –°–æ–±–∏—Ä–∞–µ–º –∏—Ç–æ–≥–æ–≤—ã–π —Ö–µ—à, –∫–æ–Ω–∫–∞—Ç–µ–Ω–∏—Ä—É—è —Ç–æ–∫–µ–Ω—ã –≤ —Ç–æ–º –∂–µ –ø–æ—Ä—è–¥–∫–µ, —á—Ç–æ –∏ —á–∞—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
	result := make([]byte, 0, hpa*sohp)
	for _, token := range tokens {
		result = append(result, token...)
	}

	return result
}

// generateToken –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—É—é —á–∞—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –∏ —Å–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –µ—ë –≤ —Ç–æ–∫–µ–Ω —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞.
// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–µ—Ç–æ–¥ XOR‚Äë—Å–≤—ë—Ä—Ç–∫–∏: –∫–∞–∂–¥—ã–π –±–∞–π—Ç —á–∞—Å—Ç–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è (XOR) –≤ —ç–ª–µ–º–µ–Ω—Ç —Ç–æ–∫–µ–Ω–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É i % size,
// –∞ –∑–∞—Ç–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è –ø–æ–±–∏—Ç–æ–≤–æ–µ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è.
func generateToken(part []byte, size int) []byte {
	token := make([]byte, size)
	// ‚è±Ô∏è XOR-—Å–≤—ë—Ä—Ç–∫–∞: —Å–∫–ª–∞–¥—ã–≤–∞–µ–º –±–∞–π—Ç—ã —á–∞—Å—Ç–∏ –ø–æ –º–æ–¥—É–ª—é —Ä–∞–∑–º–µ—Ä–∞ —Ç–æ–∫–µ–Ω–∞
	for i, b := range part {
		token[i%size] ^= b
	}
	// –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–±–∏—Ç–æ–≤–æ–µ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫ –∫–∞–∂–¥–æ–º—É –±–∞–π—Ç—É —Ç–æ–∫–µ–Ω–∞
	for i := 0; i < size; i++ {
		token[i] = ^token[i]
	}
	return token
}

// checkSimilarity checks for bandit bits (different bits) in both hashes and returns their positions
func checkSimilarity(hash1, hash2 []byte) []int {
	var banditsbits []int

	// Find the bandit bits (different bits) in both hashes and store their positions
	for i, h1 := range hash1 {
		for j, h2 := range hash2 {
			if h1 != h2 && i == j {
				banditsbits = append(banditsbits, i)
			}
		}
	}

	return banditsbits
}
